=encoding utf-8

使用 lua 和状态机技术写一个输入字符串输出 table 的函数（用于像 npm 包C<dotenv-expand>那样解析.env 文件）, 具体要求如下:


=over


=item 1.

输入字符串C< foo = bar> 得到C<{ foo = 'bar' }>, 等号两边的空格是可选的, 等号左边为 key, 仅限英文字母、数字和下划线. 每一行的开始和结尾的空格会被忽略。
另外，value 首位多余的空格会被忽略，但中间的空格会被保留，例如输入C<SPACE=  a + b = c    # comment>得到C<{ foo = 'a + b = c' }>


=back


=over


=item 1.

C<#>代表注释，它及其后面的字符被忽略，例如


=back


    foo = bar
    x=1 # this is a comment

得到C<{ foo = 'bar', x = '1' }>；
注释还可以单独成行（直接被忽略），例如：


    foo = bar
    # this is a line comment
    x=1 # this is a comment

仍然得到C<{ foo = 'bar', x = '1' }>；


=over


=item 1.

value 可以使用单引号、双引号和反引号这三种字符成对包裹：


=back


    '"`

此时 value 可以包含换行符、空格（不能被忽略）、还可以包含C<#>（此时C<#>不能解释为注释），比如输入


    foo1='1
    2'
    foo2=" 1#1
    2"
    foo3=`1#1
    2`

得到: C<{ foo1='1\n2', foo2=' 1#1\n2', foo3='1#1\n2'}>


=over


=item 1.

使用C<${X}>或C<$X>这种形式能够援引其他 Key,其中C<${X}>这种形式能够明确变量名的开始和结束部分，C<$X>则是向右一直到第一个非 key 字符出现作为结束。例如输入


=back


    X=1
    Y=2
    Z=$X+${Y}

得到:C<{ X='1', Y='2', Z='1+2'}>；
又比如输入：


    X=1
    XY=2
    Z=$XY+

得到C<{X='1',XY='2',Z='2+'}>.


=over


=item 1.

可以不提供 value，此时解析为空字符串，例如输入C<EMPTY =>,得到C<{ EMPTY = ''}>


=back

大概规则就是这些，另外特别提醒，你需要逐个字符分析，因为如果换行符是出现在成对的`'"字符里面，那么它只能被解析为普通字符。
